{"version":3,"file":null,"sources":["../src/popper/utils/getOffsetParent.js","../src/popper/utils/getStyleComputedProperty.js","../src/popper/utils/getParentNode.js","../src/popper/utils/getScrollParent.js","../src/popper/utils/getWindowSizes.js","../src/popper/utils/getOffsetRect.js","../src/popper/utils/isFixed.js","../src/popper/utils/getPosition.js","../src/popper/utils/getBoundingClientRect.js","../src/popper/utils/getScroll.js","../src/popper/utils/getOffsetRectRelativeToCustomParent.js","../src/popper/utils/getTotalScroll.js","../src/popper/utils/getBoundaries.js","../src/popper/utils/computeAutoPlacement.js","../src/popper/utils/isNative.js","../src/popper/utils/debounce.js","../src/popper/utils/find.js","../src/popper/utils/findIndex.js","../src/popper/utils/getClientRect.js","../src/popper/utils/getOuterSizes.js","../src/popper/utils/getOppositePlacement.js","../src/popper/utils/getPopperOffsets.js","../src/popper/utils/getReferenceOffsets.js","../src/popper/utils/getSupportedPropertyName.js","../src/popper/utils/isFunction.js","../src/popper/utils/isModifierEnabled.js","../src/popper/utils/isModifierRequired.js","../src/popper/utils/isNumeric.js","../src/popper/utils/isTransformed.js","../src/popper/utils/removeEventListeners.js","../src/popper/utils/runModifiers.js","../src/popper/utils/setAttributes.js","../src/popper/utils/setStyles.js","../src/popper/utils/setupEventListeners.js","../src/popper/utils/index.js","../src/popper/modifiers/applyStyle.js","../src/popper/modifiers/arrow.js","../src/popper/utils/getOppositeVariation.js","../src/popper/modifiers/flip.js","../src/popper/modifiers/keepTogether.js","../src/popper/modifiers/offset.js","../src/popper/modifiers/preventOverflow.js","../src/popper/modifiers/shift.js","../src/popper/modifiers/hide.js","../src/popper/modifiers/inner.js","../src/popper/modifiers/index.js","../src/popper/index.js"],"sourcesContent":["/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getOffsetParent(element) {\n    // NOTE: 1 DOM access here\n    const offsetParent = element.offsetParent;\n    const nodeName = offsetParent && offsetParent.nodeName;\n\n    if(!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return window.document.documentElement;\n    }\n\n    return offsetParent;\n}\n","/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nexport default function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nexport default function getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n        return window.document.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n        return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n}\n","export default function getWindowSizes() {\n    const body = window.document.body;\n    const html = window.document.documentElement;\n    return {\n        height: Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight),\n        width: Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth),\n    };\n}\n","import getWindowSizes from './getWindowSizes';\n\n/**\n * Get the position of the given element, relative to its offset parent\n * @method\n * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position - Coordinates of the element and its `scrollTop`\n */\nexport default function getOffsetRect(element) {\n    let elementRect;\n    if (element.nodeName === 'HTML') {\n        const { width, height } = getWindowSizes();\n        elementRect = {\n            width,\n            height,\n            left: 0,\n            top: 0,\n        };\n    }\n    else {\n        elementRect = {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            left: element.offsetLeft,\n            top: element.offsetTop,\n        };\n    }\n\n    elementRect.right = elementRect.left + elementRect.width;\n    elementRect.bottom = elementRect.top + elementRect.height;\n\n    // position\n    return elementRect;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element) {\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n","import getOffsetParent from './getOffsetParent';\nimport isFixed from './isFixed';\n\n/**\n * Helper used to get the position which will be applied to the popper\n * @method\n * @memberof Popper.Utils\n * @param config {HTMLElement} popper element\n * @returns {HTMLElement} reference element\n */\nexport default function getPosition(element) {\n    const container = getOffsetParent(element);\n\n    // Decide if the popper will be fixed\n    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n    const isParentFixed = isFixed(container);\n    return isParentFixed ? 'fixed' : 'absolute';\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nexport default function getBoundingClientRect(element) {\n    const isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n    let rect;\n\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    if (isIE10) {\n        try {\n            rect = element.getBoundingClientRect();\n        } catch(err) {\n            rect = {};\n        }\n    } else {\n        rect = element.getBoundingClientRect();\n    }\n\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top,\n    };\n\n    // IE10 FIX: `getBoundingClientRect`, when executed on `documentElement`\n    // will not take in account the `scrollTop` and `scrollLeft`\n    if (element.nodeName === 'HTML' && isIE10) {\n        const { scrollTop, scrollLeft } = window.document.documentElement;\n        result.top -= scrollTop;\n        result.bottom -= scrollTop;\n        result.left -= scrollLeft;\n        result.right -= scrollLeft;\n    }\n\n    // subtract scrollbar size from sizes\n    let horizScrollbar = rect.width - (element.clientWidth || rect.right - rect.left);\n    let vertScrollbar = rect.height - (element.clientHeight || rect.bottom - rect.top);\n\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= Number(styles.borderLeftWidth.split('px')[0]) + Number(styles.borderRightWidth.split('px')[0]);\n        vertScrollbar -= Number(styles.borderTopWidth.split('px')[0]) + Number(styles.borderBottomWidth.split('px')[0]);\n    }\n\n    result.right -= horizScrollbar;\n    result.width -= horizScrollbar;\n    result.bottom -= vertScrollbar;\n    result.height -= vertScrollbar;\n\n    return result;\n}\n","export default function getScroll(element, side = 'top') {\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    const nodeName = element.nodeName;\n\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        const html = window.document.documentElement;\n        const scrollingElement = window.document.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n\n    return element[upperSide];\n}\n","import getBoundingClientRect from './getBoundingClientRect';\nimport getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getOffsetParent from './getOffsetParent';\nimport getStyleComputedProperty from './getStyleComputedProperty';\n\n/**\n * Given an element and one of its parents, return the offset\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @return {Object} rect\n */\nexport default function getOffsetRectRelativeToCustomParent(element, parent, fixed = false, transformed = false) {\n    const scrollParent = getScrollParent(parent);\n    const elementRect = getBoundingClientRect(element);\n    const parentRect = getBoundingClientRect(parent);\n\n    const rect = {\n        top: elementRect.top - parentRect.top,\n        left: elementRect.left - parentRect.left,\n        bottom: (elementRect.top - parentRect.top) + elementRect.height,\n        right: (elementRect.left - parentRect.left) + elementRect.width,\n        width: elementRect.width,\n        height: elementRect.height,\n    };\n\n    if (fixed && !transformed) {\n        const scrollTop = getScroll(scrollParent, 'top');\n        const scrollLeft = getScroll(scrollParent, 'left');\n        rect.top -= scrollTop;\n        rect.bottom -= scrollTop;\n        rect.left -= scrollLeft;\n        rect.right -= scrollLeft;\n    }\n    // When a popper doesn't have any positioned or scrollable parents, `offsetParent.contains(scrollParent)`\n    // will return a \"false positive\". This is happening because `getOffsetParent` returns `html` node,\n    // and `scrollParent` is the `body` node. Hence the additional check.\n    else if (getOffsetParent(element).contains(scrollParent) && scrollParent.nodeName !== 'BODY') {\n        const scrollTop = getScroll(parent, 'top');\n        const scrollLeft = getScroll(parent, 'left');\n        rect.top += scrollTop;\n        rect.bottom += scrollTop;\n        rect.left += scrollLeft;\n        rect.right += scrollLeft;\n    }\n\n    // subtract borderTopWidth and borderTopWidth from final result\n    const styles = getStyleComputedProperty(parent);\n    const borderTopWidth = Number(styles.borderTopWidth.split('px')[0]);\n    const borderLeftWidth = Number(styles.borderLeftWidth.split('px')[0]);\n\n    rect.top -= borderTopWidth;\n    rect.bottom -= borderTopWidth;\n    rect.left -= borderLeftWidth;\n    rect.right -= borderLeftWidth;\n\n    return rect;\n}\n","import getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getParentNode from './getParentNode';\n\nexport default function getTotalScroll(element, side = 'top') {\n    const scrollParent = getScrollParent(element);\n    const scroll = getScroll(scrollParent, side);\n\n    if (['BODY', 'HTML'].indexOf(scrollParent.nodeName) === -1) {\n        return scroll + getTotalScroll(getParentNode(scrollParent), side);\n    }\n    return scroll;\n}\n","import getOffsetParent from './getOffsetParent';\nimport getScrollParent from './getScrollParent';\nimport getOffsetRect from './getOffsetRect';\nimport getPosition from './getPosition';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getTotalScroll from './getTotalScroll';\nimport isFixed from './isFixed';\nimport getWindowSizes from './getWindowSizes';\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n * @param {Number} padding - Boundaries padding\n * @param {Element} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nexport default function getBoundaries(popper, padding, boundariesElement) {\n    // NOTE: 1 DOM access here\n    let boundaries = { top: 0, left: 0 };\n    const offsetParent = getOffsetParent(popper);\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        const { left, top } = getOffsetRect(offsetParent);\n        const { clientWidth: width, clientHeight: height } = window.document.documentElement;\n\n        if (getPosition(popper) === 'fixed') {\n            boundaries.right = width;\n            boundaries.bottom = height;\n        } else {\n            const scrollLeft = getTotalScroll(popper, 'left');\n            const scrollTop = getTotalScroll(popper, 'top');\n\n            boundaries = {\n                top: 0 - top,\n                right: width - left + scrollLeft,\n                bottom: height - top + scrollTop,\n                left: 0 - left,\n            };\n        }\n    }\n    // Handle other cases based on DOM element used as boundaries\n    else {\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(popper);\n        } else if (boundariesElement === 'window') {\n            boundariesNode = window.document.body;\n        } else {\n            boundariesNode = boundariesElement;\n        }\n\n        // In case of BODY, we need a different computation\n        if (boundariesNode.nodeName === 'BODY') {\n            const { height, width } = getWindowSizes();\n            boundaries.right = width;\n            boundaries.bottom = height;\n        }\n        // for all the other DOM elements, this one is good\n        else {\n            boundaries = getOffsetRectRelativeToCustomParent(boundariesNode, offsetParent, isFixed(popper));\n        }\n    }\n\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n\n    return boundaries;\n}\n","import getBoundaries from '../utils/getBoundaries';\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function computeAutoPlacement(placement, refRect, popper) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n\n    const boundaries = getBoundaries(popper, 0, 'scrollParent');\n\n    const sides = {\n        top: refRect.top - boundaries.top,\n        right: boundaries.right - refRect.right,\n        bottom: boundaries.bottom - refRect.bottom,\n        left: refRect.left - boundaries.left,\n    };\n\n    const computedPlacement = Object.keys(sides).sort((a, b) => sides[b] - sides[a])[0];\n    const variation = placement.split('-')[1];\n\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n","const nativeHints = [\n    'native code',\n    '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @argument {Function | undefined} fn the function to check\n * @returns {boolean}\n */\nexport default fn => nativeHints.some(hint => (fn || '').toString().indexOf(hint) > -1);","import isNative from './isNative';\n\nconst longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nlet timeoutDuration = 0;\nfor (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n        timeoutDuration = 1;\n        break;\n    }\n}\n\nfunction microtaskDebounce(fn) {\n    let scheduled = false;\n    let i = 0;\n    let elem = document.createElement('span');\n\n    // MutationObserver provides a mechanism for scheduling microtasks, which\n    // are scheduled *before* the next task. This gives us a way to debounce\n    // a function but ensure it's called *before* the next paint.\n    const observer = new MutationObserver(() => {\n        fn();\n        scheduled = false;\n    });\n\n    observer.observe(elem, { attributes: true });\n\n    return () => {\n        if (!scheduled) {\n            scheduled = true;\n            elem.setAttribute('x-index', i);\n            i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n        }\n    };\n}\n\nfunction taskDebounce(fn) {\n    let scheduled = false;\n    return () => {\n        if (!scheduled) {\n            scheduled = true;\n            setTimeout(() => {\n                scheduled = false;\n                fn();\n            }, timeoutDuration);\n        }\n    };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nconst supportsNativeMutationObserver = isNative(window.MutationObserver);\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport default supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n","/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function findIndex(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n        return arr.find(check);\n    }\n\n    // use `filter` to obtain the same behavior of `find`\n    return arr.filter(check)[0];\n}\n","import find from './find';\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n        return arr.findIndex((cur) => cur[prop] === value);\n    }\n\n    // use `find` + `indexOf` if `findIndex` isn't supported\n    const match = find(arr, (obj) => (obj[prop] === value));\n    return arr.indexOf(match);\n}\n","/**\n * Given the popper offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} popperOffsets\n * @returns {Object} ClientRect like output\n */\nexport default function getClientRect(popperOffsets) {\n    return {\n        ...popperOffsets,\n        right: popperOffsets.left + popperOffsets.width,\n        bottom: popperOffsets.top + popperOffsets.height,\n    };\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nexport default function getOuterSizes(element) {\n    const styles = window.getComputedStyle(element);\n    const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    const result = {\n        width: element.offsetWidth + y,\n        height: element.offsetHeight + x\n    };\n    return result;\n}\n","/**\n * Get the opposite placement of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement) {\n    const hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);\n}\n","import getOuterSizes from './getOuterSizes';\nimport getOppositePlacement from './getOppositePlacement';\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(state, popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    const popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    const popperOffsets = {\n        position: state.position,\n        width: popperRect.width,\n        height: popperRect.height,\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n\n    return popperOffsets;\n}\n","import getOffsetParent from './getOffsetParent';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getReferenceOffsets(state, popper, reference) {\n    const isParentFixed = state.position === 'fixed';\n    const isParentTransformed = state.isParentTransformed;\n    const offsetParent = getOffsetParent((isParentFixed && isParentTransformed) ? reference : popper);\n\n    return getOffsetRectRelativeToCustomParent(reference, offsetParent, isParentFixed, isParentTransformed);\n}\n","/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nexport default function getSupportedPropertyName(property) {\n    const prefixes = [false, 'ms', 'webkit', 'moz', 'o'];\n    const upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (let i = 0; i < prefixes.length -1; i++) {\n        const prefix = prefixes[i];\n        const toCheck = prefix ? `${prefix}${upperProp}` : property;\n        if (typeof window.document.body.style[toCheck] !== 'undefined') {\n            return toCheck;\n        }\n    }\n    return null;\n}\n","/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n    const getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\n export default function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(({ name, enabled }) => enabled && name === modifierName );\n}\n","import find from './find';\n\n/**\n * Helper used to know if the given modifier depends from another one.\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport default function isModifierRequired(modifiers, requestingName, requestedName) {\n    const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n    return !!requesting && modifiers.some((modifier) => {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n}\n","/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n) {\n    return (n !== '' && !isNaN(parseFloat(n)) && isFinite(n));\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element has transforms applied to itself or a parent\n * @method\n * @memberof Popper.Utils\n * @param  {Element} element\n * @return {Boolean} answer to \"isTransformed?\"\n */\nexport default function isTransformed(element) {\n  if (element.nodeName === 'BODY') {\n      return false;\n  }\n  if (getStyleComputedProperty(element, 'transform') !== 'none') {\n      return true;\n  }\n  return getParentNode(element) ? isTransformed(getParentNode(element)) : element;\n}\n","/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function removeEventListeners(reference, state) {\n    // NOTE: 1 DOM access here\n    window.removeEventListener('resize', state.updateBound);\n    if (state.scrollElement) {\n        state.scrollElement.removeEventListener('scroll', state.updateBound);\n    }\n    state.updateBound = null;\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n}\n","import isFunction from './isFunction';\nimport findIndex from './findIndex';\n\n/**\n * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n * @method\n * @memberof Popper.Utils\n * @param {Object} data\n * @param {Array} modifiers\n * @param {Function} ends\n */\nexport default function runModifiers(modifiers, data, ends) {\n    const modifiersToRun = (ends === undefined) ?\n          modifiers :\n          modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n    modifiersToRun.forEach((modifier) => {\n        if (modifier.enabled && isFunction(modifier.function)) {\n            data = modifier.function(data, modifier);\n        }\n    });\n\n    return data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nexport default function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function(prop) {\n        const value = attributes[prop];\n        if (value !== false) {\n            element.setAttribute(prop, attributes[prop]);\n        } else {\n            element.removeAttribute(prop);\n        }\n    });\n}\n","import isNumeric from './isNumeric';\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nexport default function setStyles(element, styles) {\n    Object.keys(styles).forEach((prop) => {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        element.style[prop] = styles[prop] + unit;\n    });\n}\n","import getScrollParent from './getScrollParent';\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(reference, options, state, updateBound) {\n    // NOTE: 1 DOM access here\n    state.updateBound = updateBound;\n    window.addEventListener('resize', state.updateBound, { passive: true });\n    let target = getScrollParent(reference);\n    if (target.nodeName === 'BODY') {\n        target = window;\n    }\n    target.addEventListener('scroll', state.updateBound, { passive: true });\n    state.scrollElement = target;\n    state.eventsEnabled = true;\n\n    return state;\n}\n","import computeAutoPlacement from './computeAutoPlacement';\nimport debounce from './debounce';\nimport findIndex from './findIndex';\nimport getBoundaries from './getBoundaries';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getClientRect from './getClientRect';\nimport getOffsetParent from './getOffsetParent';\nimport getOffsetRect from './getOffsetRect';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getOuterSizes from './getOuterSizes';\nimport getParentNode from './getParentNode';\nimport getPopperOffsets from './getPopperOffsets';\nimport getPosition from './getPosition';\nimport getReferenceOffsets from './getReferenceOffsets';\nimport getScroll from './getScroll';\nimport getScrollParent from './getScrollParent';\nimport getStyleComputedProperty from './getStyleComputedProperty';\nimport getSupportedPropertyName from './getSupportedPropertyName';\nimport getTotalScroll from './getTotalScroll';\nimport getWindowSizes from './getWindowSizes';\nimport isFixed from './isFixed';\nimport isFunction from './isFunction';\nimport isModifierEnabled from './isModifierEnabled';\nimport isModifierRequired from './isModifierRequired';\nimport isNative from './isNative';\nimport isNumeric from './isNumeric';\nimport isTransformed from './isTransformed';\nimport removeEventListeners from './removeEventListeners';\nimport runModifiers from './runModifiers';\nimport setAttributes from './setAttributes';\nimport setStyles from './setStyles';\nimport setupEventListeners from './setupEventListeners';\n\n/** @namespace Popper.Utils */\nexport default {\n    computeAutoPlacement,\n    debounce,\n    findIndex,\n    getBoundaries,\n    getBoundingClientRect,\n    getClientRect,\n    getOffsetParent,\n    getOffsetRect,\n    getOffsetRectRelativeToCustomParent,\n    getOuterSizes,\n    getParentNode,\n    getPopperOffsets,\n    getPosition,\n    getReferenceOffsets,\n    getScroll,\n    getScrollParent,\n    getStyleComputedProperty,\n    getSupportedPropertyName,\n    getTotalScroll,\n    getWindowSizes,\n    isFixed,\n    isFunction,\n    isModifierEnabled,\n    isModifierRequired,\n    isNative,\n    isNumeric,\n    isTransformed,\n    removeEventListeners,\n    runModifiers,\n    setAttributes,\n    setStyles,\n    setupEventListeners,\n};\n","import getSupportedPropertyName from '../utils/getSupportedPropertyName';\nimport setStyles from '../utils/setStyles';\nimport setAttributes from '../utils/setAttributes';\nimport getReferenceOffsets from '../utils/getReferenceOffsets';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\n\n/**\n * Apply the computed styles to the popper element\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nexport default function applyStyle(data, options) {\n    // apply the final offsets to the popper\n    // NOTE: 1 DOM access here\n    const styles = {\n        position: data.offsets.popper.position\n    };\n\n    const attributes = {\n        'x-placement': data.placement,\n    };\n\n    // round top and left to avoid blurry text\n    const left = Math.round(data.offsets.popper.left);\n    const top = Math.round(data.offsets.popper.top);\n\n    // if gpuAcceleration is set to true and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    const prefixedProperty = getSupportedPropertyName('transform');\n    if (options.gpuAcceleration && prefixedProperty) {\n        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n        styles.top = 0;\n        styles.left = 0;\n        styles.willChange = 'transform';\n    }\n    // othwerise, we use the standard `left` and `top` properties\n    else {\n        styles.left =left;\n        styles.top = top;\n        styles.willChange = 'top, left';\n    }\n\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, {...styles, ...data.styles});\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, {...attributes, ...data.attributes});\n\n    // if the arrow style has been computed, apply the arrow style\n    if (data.offsets.arrow) {\n        setStyles(data.arrowElement, data.offsets.arrow);\n    }\n\n    return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used to add margins to the popper\n * margins needs to be calculated to get the correct popper offsets\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nexport function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    const referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    options.placement = computeAutoPlacement(options.placement, referenceOffsets, popper);\n\n    popper.setAttribute('x-placement', options.placement);\n    return options;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOuterSizes from '../utils/getOuterSizes';\nimport isModifierRequired from '../utils/isModifierRequired';\n\n/**\n * Modifier used to move the arrowElements on the edge of the popper to make sure them are always between the popper and the reference element\n * It will use the CSS outer size of the arrowElement element to know how many pixels of conjuction are needed\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function arrow(data, options) {\n    // arrow depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n        console.warn('WARNING: `keepTogether` modifier is required by arrow modifier in order to work, be sure to include it before `arrow`!');\n        return data;\n    }\n\n    let arrowElement  = options.element;\n\n    // if arrowElement is a string, suppose it's a CSS selector\n    if (typeof arrowElement === 'string') {\n        arrowElement = data.instance.popper.querySelector(arrowElement);\n\n        // if arrowElement is not found, don't run the modifier\n        if (!arrowElement) {\n            return data;\n        }\n    } else {\n        // if the arrowElement isn't a query selector we must check that the\n        // provided DOM node is child of its popper node\n        if (!data.instance.popper.contains(arrowElement)) {\n            console.warn('WARNING: `arrow.element` must be child of its popper element!');\n            return data;\n        }\n    }\n\n    const placement         = data.placement.split('-')[0];\n    const popper            = getClientRect(data.offsets.popper);\n    const reference         = data.offsets.reference;\n    const isVertical        = ['left', 'right'].indexOf(placement) !== -1;\n\n    const len               = isVertical ? 'height' : 'width';\n    const side              = isVertical ? 'top' : 'left';\n    const altSide           = isVertical ? 'left' : 'top';\n    const opSide            = isVertical ? 'bottom' : 'right';\n    const arrowElementSize  = getOuterSizes(arrowElement)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n        data.offsets.popper[side] += (reference[side] + arrowElementSize) - popper[opSide];\n    }\n\n    // compute center of the popper\n    const center = reference[side] + (reference[len] / 2) - (arrowElementSize / 2);\n\n    // Compute the sideValue using the updated popper offsets\n    let sideValue = center - getClientRect(data.offsets.popper)[side];\n\n    // prevent arrowElement from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = {};\n    data.offsets.arrow[side] = sideValue;\n    data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n\n    return data;\n}\n","/**\n * Get the opposite placement variation of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nexport default function getOppositeVariation(variation) {\n    if (variation === 'end') {\n        return 'start';\n    } else if (variation === 'start') {\n        return 'end';\n    }\n    return variation;\n}\n","import getOppositePlacement from '../utils/getOppositePlacement';\nimport getOppositeVariation from '../utils/getOppositeVariation';\nimport getClientRect from '../utils/getClientRect';\nimport getPopperOffsets from '../utils/getPopperOffsets';\nimport runModifiers from '../utils/runModifiers';\nimport getBoundaries from '../utils/getBoundaries';\nimport isModifierEnabled from '../utils/isModifierEnabled';\n\n/**\n * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n * Requires the `preventOverflow` modifier before it in order to work.\n * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n        return data;\n    }\n\n    if (data.flipped && data.placement === data.originalPlacement) {\n        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n        return data;\n    }\n\n    const boundaries = getBoundaries(data.instance.popper, options.padding, options.boundariesElement);\n\n    let placement = data.placement.split('-')[0];\n    let placementOpposite = getOppositePlacement(placement);\n    let variation = data.placement.split('-')[1] || '';\n\n    let flipOrder = [];\n\n    if (options.behavior === 'flip') {\n        flipOrder = [\n            placement,\n            placementOpposite\n        ];\n    } else {\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach((step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n\n        placement = data.placement.split('-')[0];\n        placementOpposite = getOppositePlacement(placement);\n\n        const popperOffsets = getClientRect(data.offsets.popper);\n        const refOffsets = data.offsets.reference;\n\n        // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n        const overlapsRef = (\n            (placement === 'left'   && Math.floor(popperOffsets.right) > Math.floor(refOffsets.left)) ||\n            (placement === 'right'  && Math.floor(popperOffsets.left) < Math.floor(refOffsets.right)) ||\n            (placement === 'top'    && Math.floor(popperOffsets.bottom) > Math.floor(refOffsets.top)) ||\n            (placement === 'bottom' && Math.floor(popperOffsets.top) < Math.floor(refOffsets.bottom))\n        );\n\n        const overflowsBoundaries = (\n            (placement === 'left'   && Math.floor(popperOffsets.left) < Math.floor(boundaries.left)) ||\n            (placement === 'right'  && Math.floor(popperOffsets.right) > Math.floor(boundaries.right)) ||\n            (placement === 'top'    && Math.floor(popperOffsets.top) < Math.floor(boundaries.top)) ||\n            (placement === 'bottom' && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom))\n        );\n\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = !!options.flipVariations && (\n            (isVertical  && variation === 'start' && Math.floor(popperOffsets.left) < Math.floor(boundaries.left)) ||\n            (isVertical  && variation === 'end'   && Math.floor(popperOffsets.right) > Math.floor(boundaries.right)) ||\n            (!isVertical && variation === 'start' && Math.floor(popperOffsets.top) < Math.floor(boundaries.top)) ||\n            (!isVertical && variation === 'end'   && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom))\n        );\n\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            // this boolean to detect any flip loop\n            data.flipped = true;\n\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n\n            data.placement = placement + (variation ? '-' + variation : '');\n            data.offsets.popper = getPopperOffsets(data.instance.state, data.instance.popper, data.offsets.reference, data.placement);\n\n            data = runModifiers(data.instance.modifiers, data, 'flip');\n        }\n    });\n    return data;\n}\n","import getClientRect from '../utils/getClientRect';\n\n/**\n * Modifier used to make sure the popper is always near its reference element\n * It cares only about the first axis, you can still have poppers with margin\n * between the popper and its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function keepTogether(data) {\n    const popper  = getClientRect(data.offsets.popper);\n    const reference = data.offsets.reference;\n    const placement = data.placement.split('-')[0];\n    const floor = Math.floor;\n\n    if (['top', 'bottom'].indexOf(placement) !== -1) {\n        if (popper.right < floor(reference.left)) {\n            data.offsets.popper.left = floor(reference.left) - popper.width;\n        }\n        if (popper.left > floor(reference.right)) {\n            data.offsets.popper.left = floor(reference.right);\n        }\n    } else {\n        if (popper.bottom < floor(reference.top)) {\n            data.offsets.popper.top = floor(reference.top) - popper.height;\n        }\n        if (popper.top > floor(reference.bottom)) {\n            data.offsets.popper.top = floor(reference.bottom);\n        }\n    }\n\n    return data;\n}\n","import isNumeric from '../utils/isNumeric';\nimport getClientRect from '../utils/getClientRect';\n\n/**\n * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n * The offsets will shift the popper on the side of its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n *      Basic usage allows a number used to nudge the popper by the given amount of pixels.\n *      You can pass a percentage value as string (eg. `20%`) to nudge by the given percentage (relative to reference element size)\n *      Other supported units are `vh` and `vw` (relative to viewport)\n *      Additionally, you can pass a pair of values (eg. `10 20` or `2vh 20%`) to nudge the popper\n *      on both axis.\n *      A note about percentage values, if you want to refer a percentage to the popper size instead of the reference element size,\n *      use `%p` instead of `%` (eg: `20%p`). To make it clearer, you can replace `%` with `%r` and use eg.`10%p 25%r`.\n *      > **Heads up!** The order of the axis is relative to the popper placement: `bottom` or `top` are `X,Y`, the other are `Y,X`\n * @returns {Object} The data object, properly modified\n */\nexport default function offset(data, options) {\n    const placement = data.placement;\n    const popper  = data.offsets.popper;\n\n    let offsets;\n    if (isNumeric(options.offset)) {\n        offsets = [options.offset, 0];\n    } else {\n        // split the offset in case we are providing a pair of offsets separated\n        // by a blank space\n        offsets = options.offset.split(' ');\n\n        // itherate through each offset to compute them in case they are percentages\n        offsets = offsets.map((offset, index) => {\n            // separate value from unit\n            const split = offset.match(/(\\d*\\.?\\d*)(.*)/);\n            const value = +split[1];\n            const unit = split[2];\n\n            // use height if placement is left or right and index is 0 otherwise use width\n            // in this way the first offset will use an axis and the second one\n            // will use the other one\n            let useHeight = placement.indexOf('right') !== -1 || placement.indexOf('left') !== -1;\n\n            if (index === 1) {\n                useHeight = !useHeight;\n            }\n\n            const measurement = useHeight ? 'height' : 'width';\n\n            // if is a percentage, we calculate the value of it using as base the\n            // sizes of the reference element\n            if (unit === '%' || unit === '%r') {\n                const referenceRect = getClientRect(data.offsets.reference);\n                let len = referenceRect[measurement];\n                return (len / 100) * value;\n            }\n            // if is a percentage relative to the popper, we calculate the value of it using\n            // as base the sizes of the popper\n            else if (unit === '%p') {\n                const popperRect = getClientRect(data.offsets.popper);\n                let len = popperRect[measurement];\n                return (len / 100) * value;\n            }\n            // if is a vh or vw, we calculate the size based on the viewport\n            else if (unit === 'vh' || unit === 'vw') {\n                let size;\n                if (unit === 'vh') {\n                    size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                } else {\n                    size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                }\n                return (size / 100) * value;\n            }\n            // if is an explicit pixel unit, we get rid of the unit and keep the value\n            else if (unit === 'px') {\n                return +value;\n            }\n            // if is an implicit unit, it's px, and we return just the value\n            else {\n                return +offset;\n            }\n        });\n    }\n\n    if (data.placement.indexOf('left') !== -1) {\n        popper.top += offsets[0];\n        popper.left -= offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('right') !== -1) {\n        popper.top += offsets[0];\n        popper.left += offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('top') !== -1) {\n        popper.left += offsets[0];\n        popper.top -= offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('bottom') !== -1) {\n        popper.left += offsets[0];\n        popper.top += offsets[1] || 0;\n    }\n    return data;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getOffsetParent from '../utils/getOffsetParent';\nimport getBoundaries from '../utils/getBoundaries';\n\n/**\n * Modifier used to prevent the popper from being positioned outside the boundary.\n *\n * An scenario exists where the reference itself is not within the boundaries. We can\n * say it has \"escaped the boundaries\" — or just \"escaped\". In this case we need to\n * decide whether the popper should either:\n *\n * - detach from the reference and remain \"trapped\" in the boundaries, or\n * - if it should be ignore the boundary and \"escape with the reference\"\n *\n * When `escapeWithReference` is `true`, and reference is completely outside the\n * boundaries, the popper will overflow (or completely leave) the boundaries in order\n * to remain attached to the edge of the reference.\n *\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function preventOverflow(data, options) {\n    const boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n    const boundaries = getBoundaries(data.instance.popper, options.padding, boundariesElement);\n    options.boundaries = boundaries;\n\n    const order = options.priority;\n    let popper = getClientRect(data.offsets.popper);\n\n    const check = {\n        left() {\n            let left = popper.left;\n            if (popper.left < boundaries.left && !shouldOverflowBoundary(data, options, 'left')) {\n                left = Math.max(popper.left, boundaries.left);\n            }\n            return { left };\n        },\n        right() {\n            let left = popper.left;\n            if (popper.right > boundaries.right && !shouldOverflowBoundary(data, options, 'right')) {\n                left = Math.min(popper.left, boundaries.right - popper.width);\n            }\n            return { left };\n        },\n        top() {\n            let top = popper.top;\n            if (popper.top < boundaries.top && !shouldOverflowBoundary(data, options, 'top')) {\n                top = Math.max(popper.top, boundaries.top);\n            }\n            return { top };\n        },\n        bottom() {\n            let top = popper.top;\n            if (popper.bottom > boundaries.bottom && !shouldOverflowBoundary(data, options, 'bottom')) {\n                top = Math.min(popper.top, boundaries.bottom - popper.height);\n            }\n            return { top };\n        }\n    };\n\n    order.forEach((direction) => {\n        popper = {...popper, ...check[direction]()};\n    });\n\n    data.offsets.popper = popper;\n\n    return data;\n}\n\n/**\n * Determine if the popper should overflow a boundary edge to stay together with the reference.\n */\nfunction shouldOverflowBoundary(data, options, overflowDirection) {\n    if (!options.escapeWithReference) {\n        return false;\n    }\n\n    if (data.flipped && isSameAxis(data.originalPlacement, overflowDirection)) {\n        return true;\n    }\n\n    if (!isSameAxis(data.originalPlacement, overflowDirection)) {\n        return true;\n    }\n\n    return true;\n}\n\n/**\n * Determine if two placement values are on the same axis.\n */\nfunction isSameAxis(a, b) {\n    // placement syntax:\n    //\n    //     ( \"top\" | \"right\" | \"bottom\" | \"left\" ) ( \"-start\" | \"\" | \"-end\" )\n    //     |------------- Direction -------------|\n    //\n    const aDirection = a.split('-')[0];\n    const bDirection = b.split('-')[0];\n\n    return aDirection === bDirection || aDirection === getOppositePlacement(b);\n}\n","import getClientRect from '../utils/getClientRect';\n\n/**\n * Modifier used to shift the popper on the start or end of its reference element side\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function shift(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split('-')[0];\n    const shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n        const reference = data.offsets.reference;\n        const popper = getClientRect(data.offsets.popper);\n\n        const shiftOffsets = {\n            y: {\n                start:  { top: reference.top },\n                end:    { top: reference.top + reference.height - popper.height }\n            },\n            x: {\n                start:  { left: reference.left },\n                end:    { left: reference.left + reference.width - popper.width }\n            }\n        };\n\n        const axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n\n        data.offsets.popper = {...popper, ...shiftOffsets[axis][shiftvariation]};\n    }\n\n    return data;\n}\n","import isModifierRequired from '../utils/isModifierRequired';\nimport find from '../utils/find';\n\n/**\n * Modifier used to hide the popper when its reference element is outside of the\n * popper boundaries. It will set an x-hidden attribute which can be used to hide\n * the popper when its reference is out of boundaries.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n        console.warn('WARNING: preventOverflow modifier is required by hide modifier in order to work, be sure to include it before hide!');\n        return data;\n    }\n\n    const refRect = data.offsets.reference;\n    const bound = find(data.instance.modifiers, (modifier) => modifier.name ==='preventOverflow').boundaries;\n\n    if (\n        refRect.bottom < bound.top ||\n        refRect.left > bound.right ||\n        refRect.top > bound.bottom ||\n        refRect.right < bound.left\n    ) {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === true) { return data; }\n\n        data.hide = true;\n        data.attributes['x-out-of-boundaries'] = '';\n    } else {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === false) { return data; }\n\n        data.hide = false;\n        data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOppositePlacement from '../utils/getOppositePlacement';\n\n/**\n * Modifier used to make the popper flow toward the inner of the reference element.\n * By default, when this modifier is disabled, the popper will be placed outside\n * the reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function inner(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split('-')[0];\n    const popper = getClientRect(data.offsets.popper);\n    const reference = getClientRect(data.offsets.reference);\n    const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n    const subtractLength = (['top', 'left'].indexOf(basePlacement) === -1);\n\n    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n\n    return data;\n}\n","import applyStyle, { applyStyleOnLoad } from './applyStyle';\nimport arrow from './arrow';\nimport flip from './flip';\nimport keepTogether from './keepTogether';\nimport offset from './offset';\nimport preventOverflow from './preventOverflow';\nimport shift from './shift';\nimport hide from './hide';\nimport inner from './inner';\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.\n * Popper.js uses a set of 7 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Each modifier is an object containing several properties listed below.\n * @namespace Modifiers\n * @param {Object} modifier - Modifier descriptor\n * @param {Integer} modifier.order\n *      The `order` property defines the execution order of the modifiers.\n *      The built-in modifiers have orders with a gap of 100 units in between,\n *      this allows you to inject additional modifiers between the existing ones\n *      without having to redefine the order of all of them.\n *      The modifiers are executed starting from the one with the lowest order.\n * @param {Boolean} modifier.enabled - When `true`, the modifier will be used.\n * @param {Modifiers~modifier} modifier.function - Modifier function.\n * @param {Modifiers~onLoad} modifier.onLoad - Function executed on popper initalization\n * @return {Object} data - Each modifier must return the modified `data` object.\n */\nexport default {\n     shift: {\n         order: 100,\n         enabled: true,\n         function: shift,\n     },\n     offset: {\n         order: 200,\n         enabled: true,\n         function: offset,\n         // nudges popper from its origin by the given amount of pixels (can be negative)\n         offset: 0,\n     },\n     preventOverflow: {\n         order: 300,\n         enabled: true,\n         function: preventOverflow,\n         // popper will try to prevent overflow following these priorities\n         //  by default, then, it could overflow on the left and on top of the boundariesElement\n         priority: ['left', 'right', 'top', 'bottom'],\n         // amount of pixel used to define a minimum distance between the boundaries and the popper\n         // this makes sure the popper has always a little padding between the edges of its container\n         padding: 5,\n         boundariesElement: 'scrollParent',\n     },\n     keepTogether: {\n         order: 400,\n         enabled: true,\n         function: keepTogether\n     },\n     arrow: {\n         order: 500,\n         enabled: true,\n         function: arrow,\n         // selector or node used as arrow\n         element: '[x-arrow]'\n     },\n     flip: {\n         order: 600,\n         enabled: true,\n         function: flip,\n         // the behavior used to change the popper's placement\n         behavior: 'flip',\n         // the popper will flip if it hits the edges of the boundariesElement - padding\n         padding: 5,\n         boundariesElement: 'viewport'\n     },\n     inner: {\n         order: 700,\n         enabled: false,\n         function: inner,\n     },\n     hide: {\n         order: 800,\n         enabled: true,\n         function: hide\n     },\n     applyStyle: {\n         order: 900,\n         enabled: true,\n         // if true, it uses the CSS 3d transformation to position the popper\n         gpuAcceleration: true,\n         function: applyStyle,\n         onLoad: applyStyleOnLoad,\n     }\n }\n\n\n /**\n  * Modifiers can edit the `data` object to change the beheavior of the popper.\n  * This object contains all the informations used by Popper.js to compute the\n  * popper position.\n  * The modifier can edit the data as needed, and then `return` it as result.\n  *\n  * @callback Modifiers~modifier\n  * @param {dataObject} data\n  * @return {dataObject} modified data\n  */\n\n /**\n  * The `dataObject` is an object containing all the informations used by Popper.js\n  * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n  * @name dataObject\n  * @property {Object} data.instance The Popper.js instance\n  * @property {String} data.placement Placement applied to popper\n  * @property {String} data.originalPlacement Placement originally defined on init\n  * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n  * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n  * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n  * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n  * @property {Object} data.boundaries Offsets of the popper boundaries\n  * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n  * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n  * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n  * @property {Object} data.offsets.arro] `top` and `left` offsets, only one of them will be different from 0\n  */\n","// Utils\nimport Utils from './utils/index';\nimport debounce from './utils/debounce';\nimport setStyles from './utils/setStyles';\nimport isTransformed from './utils/isTransformed';\nimport getSupportedPropertyName from './utils/getSupportedPropertyName';\nimport getPosition from './utils/getPosition';\nimport getReferenceOffsets from './utils/getReferenceOffsets';\nimport getPopperOffsets from './utils/getPopperOffsets';\nimport isFunction from './utils/isFunction';\nimport setupEventListeners from './utils/setupEventListeners';\nimport removeEventListeners from './utils/removeEventListeners';\nimport runModifiers from './utils/runModifiers';\nimport isModifierEnabled from './utils/isModifierEnabled';\nimport computeAutoPlacement from './utils/computeAutoPlacement';\n\n// Modifiers\nimport modifiers from './modifiers/index';\n\n// default options\nconst DEFAULTS = {\n    // placement of the popper\n    placement: 'bottom',\n\n    // whether events (resize, scroll) are initially enabled\n    eventsEnabled: true,\n\n    /**\n     * Callback called when the popper is created.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback createCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onCreate: () => {},\n\n    /**\n     * Callback called when the popper is updated, this callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback updateCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onUpdate: () => {},\n\n    // list of functions used to modify the offsets before they are applied to the popper\n    modifiers,\n};\n\n/**\n * Create a new Popper.js instance\n * @class Popper\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options\n * @param {String} options.placement=bottom\n *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),\n *      left(-start, -end)`\n *\n * @param {Boolean} options.eventsEnabled=true\n *      Whether events (resize, scroll) are initially enabled\n * @param {Boolean} options.gpuAcceleration=true\n *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n *      browser to use the GPU to accelerate the rendering.\n *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n *\n * @param {Boolean} options.removeOnDestroy=false\n *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n *\n * @param {Object} options.modifiers\n *      List of functions used to modify the data before they are applied to the popper (see source code for default values)\n *\n * @param {Object} options.modifiers.arrow - Arrow modifier configuration\n * @param {String|HTMLElement} options.modifiers.arrow.element='[x-arrow]'\n *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n *      reference element.\n *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n *\n * @param {Object} options.modifiers.offset - Offset modifier configuration\n * @param {Number} options.modifiers.offset.offset=0\n *      Amount of pixels the popper will be shifted (can be negative).\n *\n * @param {Object} options.modifiers.preventOverflow - PreventOverflow modifier configuration\n * @param {Array} [options.modifiers.preventOverflow.priority=['left', 'right', 'top', 'bottom']]\n *      Priority used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n *      this means that the last one will never overflow\n * @param {String|HTMLElement} options.modifiers.preventOverflow.boundariesElement='scrollParent'\n *      Boundaries used by the modifier, can be `scrollParent`, `window`, `viewport` or any DOM element.\n * @param {Number} options.modifiers.preventOverflow.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {Object} options.modifiers.flip - Flip modifier configuration\n * @param {String|Array} options.modifiers.flip.behavior='flip'\n *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n *      its axis (`right - left`, `top - bottom`).\n *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n * @param {String|HTMLElement} options.modifiers.flip.boundariesElement='viewport'\n *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n *      of the defined boundaries (except if `keepTogether` is enabled)\n *\n * @param {Object} options.modifiers.inner - Inner modifier configuration\n * @param {Number} options.modifiers.innner.enabled=false\n *      Set to `true` to make the popper flow toward the inner of the reference element.\n *\n * @param {Number} options.modifiers.flip.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {createCallback} options.onCreate - onCreate callback\n *      Function called after the Popper has been instantiated.\n *\n * @param {updateCallback} options.onUpdate - onUpdate callback\n *      Function called on subsequent updates of Popper.\n *\n * @return {Object} instance - The generated Popper.js instance\n */\nexport default class Popper {\n    constructor(reference, popper, options = {}) {\n        // make update() debounced, so that it only runs at most once-per-tick\n        this.update = debounce(this.update.bind(this));\n\n        // with {} we create a new object with the options inside it\n        this.options = {...Popper.Defaults, ...options};\n\n        // init state\n        this.state = {\n            isDestroyed: false,\n            isCreated: false,\n        };\n\n        // get reference and popper elements (allow jQuery wrappers)\n        this.reference = reference.jquery ? reference[0] : reference;\n        this.popper = popper.jquery ? popper[0] : popper;\n\n        // refactoring modifiers' list (Object => Array)\n        this.modifiers = Object.keys(Popper.Defaults.modifiers)\n                               .map((name) => ({name, ...Popper.Defaults.modifiers[name]}));\n\n        // assign default values to modifiers, making sure to override them with\n        // the ones defined by user\n        this.modifiers = this.modifiers.map((defaultConfig) => {\n            const userConfig = (options.modifiers && options.modifiers[defaultConfig.name]) || {};\n            return {...defaultConfig, ...userConfig};\n        });\n\n        // add custom modifiers to the modifiers list\n        if (options.modifiers) {\n            this.options.modifiers = {...{}, ...Popper.Defaults.modifiers, ...options.modifiers};\n            Object.keys(options.modifiers).forEach((name) => {\n                // take in account only custom modifiers\n                if (Popper.Defaults.modifiers[name] === undefined) {\n                    const modifier = options.modifiers[name];\n                    modifier.name = name;\n                    this.modifiers.push(modifier);\n                }\n            });\n        }\n\n        // get the popper position type\n        this.state.position = getPosition(this.reference);\n\n        // sort the modifiers by order\n        this.modifiers = this.modifiers.sort((a, b) => a.order - b.order);\n\n        // modifiers have the ability to execute arbitrary code when Popper.js get inited\n        // such code is executed in the same order of its modifier\n        // they could add new properties to their options configuration\n        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n        this.modifiers.forEach((modifierOptions) => {\n            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n                modifierOptions.onLoad(\n                    this.reference,\n                    this.popper,\n                    this.options,\n                    modifierOptions,\n                    this.state\n                );\n            }\n        });\n\n        // determine how we should set the origin of offsets\n        this.state.isParentTransformed = isTransformed(this.popper.parentNode);\n\n        // fire the first update to position the popper in the right place\n        this.update();\n\n        const eventsEnabled = this.options.eventsEnabled;\n        if (eventsEnabled) {\n            // setup event listeners, they will take care of update the position in specific situations\n            this.enableEventListeners();\n        }\n\n        this.state.eventsEnabled = eventsEnabled;\n    }\n\n    //\n    // Methods\n    //\n\n    /**\n     * Updates the position of the popper, computing the new offsets and applying the new style\n     * Prefer `scheduleUpdate` over `update` because of performance reasons\n     * @method\n     * @memberof Popper\n     */\n    update() {\n        // if popper is destroyed, don't perform any further update\n        if (this.state.isDestroyed) { return; }\n\n        let data = {\n            instance: this,\n            styles: {},\n            attributes: {},\n            flipped: false,\n            offsets: {},\n        };\n\n        // make sure to apply the popper position before any computation\n        this.state.position = getPosition(this.reference);\n        setStyles(this.popper, { position: this.state.position});\n\n        // compute reference element offsets\n        data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n\n        // compute auto placement, store placement inside the data object,\n        // modifiers will be able to edit `placement` if needed\n        // and refer to originalPlacement to know the original value\n        data.placement = computeAutoPlacement(\n            this.options.placement,\n            data.offsets.reference,\n            this.popper\n        );\n\n        // store the computed placement inside `originalPlacement`\n        data.originalPlacement = this.options.placement;\n\n        // compute the popper offsets\n        data.offsets.popper = getPopperOffsets(\n            this.state,\n            this.popper,\n            data.offsets.reference,\n            data.placement\n        );\n\n        // run the modifiers\n        data = runModifiers(this.modifiers, data);\n\n        // the first `update` will call `onCreate` callback\n        // the other ones will call `onUpdate` callback\n        if (!this.state.isCreated) {\n            this.state.isCreated = true;\n            this.options.onCreate(data);\n        } else {\n            this.options.onUpdate(data);\n        }\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method\n     * @memberof Popper\n     */\n    scheduleUpdate = () => requestAnimationFrame(this.update);\n\n    /**\n     * Destroy the popper\n     * @method\n     * @memberof Popper\n     */\n    destroy() {\n        this.state.isDestroyed = true;\n\n        // touch DOM only if `applyStyle` modifier is enabled\n        if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n            this.popper.removeAttribute('x-placement');\n            this.popper.style.left = '';\n            this.popper.style.position = '';\n            this.popper.style.top = '';\n            this.popper.style[getSupportedPropertyName('transform')] = '';\n        }\n\n        this.disableEventListeners();\n\n        // remove the popper if user explicity asked for the deletion on destroy\n        // do not use `remove` because IE11 doesn't support it\n        if (this.options.removeOnDestroy) {\n            this.popper.parentNode.removeChild(this.popper);\n        }\n        return this;\n    }\n\n    /**\n     * it will add resize/scroll events and start recalculating\n     * position of the popper element when they are triggered\n     * @method\n     * @memberof Popper\n     */\n    enableEventListeners() {\n        if (!this.state.eventsEnabled) {\n            this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n        }\n    }\n\n    /**\n     * it will remove resize/scroll events and won't recalculate\n     * popper position when they are triggered. It also won't trigger onUpdate callback anymore,\n     * unless you call 'update' method manually.\n     * @method\n     * @memberof Popper\n     */\n    disableEventListeners() {\n        if (this.state.eventsEnabled) {\n            cancelAnimationFrame(this.scheduledUpdate);\n            this.state = removeEventListeners(this.reference, this.state);\n        }\n    }\n\n    /**\n     * Collection of utilities useful when writing custom modifiers\n     * @memberof Popper\n     */\n    static Utils = Utils;\n\n    /**\n     * List of accepted placements to use as values of the `placement` option\n     * @memberof Popper\n     */\n     static placements = [\n         'auto',\n         'auto-start',\n         'auto-end',\n         'top',\n         'top-start',\n         'top-end',\n         'right',\n         'right-start',\n         'right-end',\n         'bottom',\n         'bottom-start',\n         'bottom-end',\n         'left',\n         'left-start',\n         'left-end',\n     ];\n\n    /**\n     * Default Popper.js options\n     * @memberof Popper\n     */\n    static Defaults = DEFAULTS;\n}\n"],"names":["getOffsetParent","element","offsetParent","nodeName","window","document","documentElement","getStyleComputedProperty","property","nodeType","css","getComputedStyle","getParentNode","parentNode","host","getScrollParent","indexOf","body","overflow","overflowX","overflowY","test","getWindowSizes","html","Math","max","scrollHeight","offsetHeight","clientHeight","scrollWidth","offsetWidth","clientWidth","getOffsetRect","elementRect","width","height","offsetLeft","offsetTop","right","left","bottom","top","isFixed","getPosition","container","isParentFixed","getBoundingClientRect","isIE10","navigator","appVersion","rect","err","result","scrollTop","scrollLeft","horizScrollbar","vertScrollbar","styles","Number","borderLeftWidth","split","borderRightWidth","borderTopWidth","borderBottomWidth","getScroll","side","upperSide","scrollingElement","getOffsetRectRelativeToCustomParent","parent","fixed","transformed","scrollParent","parentRect","contains","getTotalScroll","scroll","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","computeAutoPlacement","placement","refRect","sides","computedPlacement","Object","keys","sort","a","b","variation","nativeHints","some","fn","toString","hint","longerTimeoutBrowsers","timeoutDuration","i","length","userAgent","microtaskDebounce","scheduled","elem","createElement","observer","MutationObserver","observe","attributes","setAttribute","taskDebounce","supportsNativeMutationObserver","isNative","findIndex","arr","check","Array","prototype","find","filter","prop","value","cur","match","obj","getClientRect","popperOffsets","getOuterSizes","x","parseFloat","marginTop","marginBottom","y","marginLeft","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","state","referenceOffsets","popperRect","position","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","reference","isParentTransformed","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","isFunction","functionToCheck","getType","call","isModifierEnabled","modifiers","modifierName","name","enabled","isModifierRequired","requestingName","requestedName","requesting","modifier","order","isNumeric","n","isNaN","isFinite","isTransformed","removeEventListeners","removeEventListener","updateBound","scrollElement","eventsEnabled","runModifiers","data","ends","modifiersToRun","undefined","forEach","function","setAttributes","removeAttribute","setStyles","unit","setupEventListeners","options","addEventListener","passive","target","applyStyle","offsets","round","prefixedProperty","gpuAcceleration","willChange","instance","arrow","arrowElement","applyStyleOnLoad","modifierOptions","warn","querySelector","isVertical","len","altSide","opSide","arrowElementSize","center","sideValue","min","getOppositeVariation","flip","flipped","originalPlacement","placementOpposite","flipOrder","behavior","step","index","refOffsets","overlapsRef","floor","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","offset","map","useHeight","referenceRect","size","innerHeight","innerWidth","preventOverflow","priority","shouldOverflowBoundary","direction","overflowDirection","escapeWithReference","isSameAxis","aDirection","bDirection","shift","basePlacement","shiftvariation","shiftOffsets","axis","hide","bound","inner","subtractLength","DEFAULTS","Popper","scheduleUpdate","requestAnimationFrame","update","debounce","bind","Defaults","jquery","defaultConfig","userConfig","push","onLoad","enableEventListeners","isDestroyed","isCreated","onCreate","onUpdate","disableEventListeners","removeOnDestroy","removeChild","scheduledUpdate","Utils","placements"],"mappings":"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"}